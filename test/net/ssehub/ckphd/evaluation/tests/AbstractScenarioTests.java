/*
 * Copyright 2020 University of Hildesheim, Software Systems Engineering
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
 * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package net.ssehub.ckphd.evaluation.tests;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.fail;

import java.io.File;
import java.io.FilenameFilter;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

import net.ssehub.ckphd.evaluation.core.Executor;
import net.ssehub.ckphd.evaluation.utilities.FileUtilities;
import net.ssehub.ckphd.evaluation.utilities.FileUtilitiesException;

/**
 * This abstract class summarizes the generic attributes and methods required to perform an specific scenario test.
 * 
 * @author Christian Kroeher
 *
 */
public class AbstractScenarioTests {
    
    /**
     * The {@link List} of {@link String}s representing the line-wise content of the commit sequence file located in the
     * commit sequence directory given to the {@link #setUp(File, File)}.
     */
    protected static List<String> commitSequence;
    
    /**
     * The set of {@link File}s denoting the commit files located in the commit sequence directory given to the
     * {@link #setUp(File, File)}.
     */
    protected static File[] commitFiles;
    
    /**
     * The set of {@link File}s denoting the output files generated by the pre-commit hook during
     * {@link #setUp(File, File)}. Each of these files contains the git diff information created by applying one of the
     * commits represented by the {@link #commitFiles}.
     */
    protected static File[] gitDiffOutputFiles;
    
    /**
     * The {@link String} denoting the specific git diff command used as part of the pre-commit hook actions during
     * {@link #setUp(File, File)}.
     */
    private static final String GIT_DIFF_COMMAND = "git diff --cached -U100000 --no-renames";
    
    /**
     * The {@link String} marking the first line of git diff information in a commit.
     */
    private static final String GIT_DIFF_START_MARKER = "diff --git";
        
    /**
     * The prefix of the file containing the commit sequence, e.g., "CommitSequence_1.txt".
     */
    private static final String COMMIT_SEQUENCE_FILE_NAME_PREFIX = "CommitSequence";
    
    /**
     * The {@link File} denoting the temporary directory to be used for saving any files necessary to perform scenario
     * tests. This directory is always named "temp_testdata" and located in the {@link AllTests#TEST_DATA_DIRECTORY}.
     */
    private static final File TEMPORARY_DIRECTORY = new File(AllTests.TEST_DATA_DIRECTORY, "temp_testdata");
    
    /**
     * Creates the {@link #TEMPORARY_DIRECTORY} and the pre-commit hook actions with that directory before calling
     * {@link Executor#main(String[])} with the given repository archive file, commit sequence directory, and that hook
     * actions. The result of this method is a set of files located in the {@link #TEMPORARY_DIRECTORY}, where each file
     * contains the output of the {@link #GIT_DIFF_COMMAND} for exactly one of the applied commits of the commit
     * sequence in the given commit sequence directory.
     * 
     * @param repositoryArchiveFile the {@link File} denoting an archive in which the repository is stored, which shall
     *        be used for the current test
     * @param commitSequenceDirectory the {@link File} denoting the directory, which contains the commit sequence file
     *        and the corresponding commit files to use in the current test
     */
    protected static void setUp(File repositoryArchiveFile, File commitSequenceDirectory) {
        System.out.println(System.lineSeparator() + "#### Scenario Tests Setup ####");
        System.out.println("Repository archive file: " + repositoryArchiveFile.getAbsolutePath());
        System.out.println("Commit sequence directory: " + commitSequenceDirectory.getAbsolutePath());
        System.out.println("#### Scenario Tests Setup ####");
        // Create the temporary directory
        if (TEMPORARY_DIRECTORY.exists() && !AllTests.delete(TEMPORARY_DIRECTORY)) {
            fail("Deleting existing temporary directory failed");
        }
        if (!TEMPORARY_DIRECTORY.mkdir()) {
            fail("Creating new temporary directory failed");
        }
        // Create the pre-commit hook actions
        Path hookPipePathPrefix = Paths.get(TEMPORARY_DIRECTORY.getAbsolutePath(), "temp_");
        hookPipePathPrefix = hookPipePathPrefix.normalize();
        String hookPipePathPrefixString = hookPipePathPrefix.toString();
        hookPipePathPrefixString = hookPipePathPrefixString.replace('\\', '/'); // Unix paths for bash (pre-commit hook)
        String hookActions = "timestamp=$(date \"+%Y%m%d%H%M%S\")"
                + System.lineSeparator() + GIT_DIFF_COMMAND + " > " + hookPipePathPrefixString + "$timestamp";
        // Combine given parameters with created hook actions to executor argument set
        String[] args = {repositoryArchiveFile.getAbsolutePath(), commitSequenceDirectory.getAbsolutePath(),
            hookActions};
        // Execute the evaluation with the given and created arguments
        Executor.main(args);
        // Finally, set the attributes required for the scenario tests
        commitSequence = getCommitSequence(commitSequenceDirectory);
        commitFiles = getCommitFiles(commitSequenceDirectory);
        gitDiffOutputFiles = TEMPORARY_DIRECTORY.listFiles();
    }
    
    /**
     * Deletes the {@link #TEMPORARY_DIRECTORY} and all nested files.
     */
    protected static void tearDown() {        
        if (TEMPORARY_DIRECTORY.exists() && !AllTests.delete(TEMPORARY_DIRECTORY)) {
            fail("Deleting existing temporary directory failed");
        }
        System.out.println("#### Scenario Tests Teardown ####");
        System.out.println("Deleted temporary directory: " + TEMPORARY_DIRECTORY.getAbsolutePath());
        System.out.println("#### Scenario Tests Teardown ####" + System.lineSeparator());
    }
    
    /**
     * Returns the {@link File} from the given set of {@link File}s with a file name equal to the given {@link String},
     * which denotes a commit hash or number.
     * 
     * @param commitFiles the set of {@link File}s in which the commit file should be found
     * @param commit the {@link String} denoting a commit hash or number for which the corresponding commit file should
     *        be found
     * @return the {@link File} denoting the commit file or <code>null</code>, if no such file is available in the given
     *         set of files
     */
    protected File getCommitFile(File[] commitFiles, String commit) {
        File commitFile = null;
        int commitFileCounter = 0;
        while (commitFile == null && commitFileCounter < commitFiles.length) {
            if (commitFiles[commitFileCounter].getName().equals(commit)) {
                commitFile = commitFiles[commitFileCounter];
            }
            commitFileCounter++;
        }
        return commitFile;
    }
    
    /**
     * Compares the diff information in the two given {@link List}s of {@link String}s line-wise starting from the line
     * (index), which starts with the {@link #GIT_DIFF_START_MARKER} in each of that lists.
     *  
     * @param gitDiffOutputFileContent the {@link List} of {@link String}s denoting the content of the diff git output
     *        file generated by the pre-commit hook for each applied commit
     * @param commitFileContent the {@link List} of {@link String}s denoting the content of the commit file providing
     *        the changes applied to the repository and triggering the pre-commit hook
     */
    protected void compareDiff(List<String> gitDiffOutputFileContent, List<String> commitFileContent) {
        int gitDiffOutputFileStartLine = getGitDiffStartLine(gitDiffOutputFileContent);
        assertNotEquals(-1, gitDiffOutputFileStartLine, "Git diff output file content has no diff information");
        int commitFileStartLine = getGitDiffStartLine(commitFileContent);
        assertNotEquals(-1, commitFileStartLine, "Commit file content has no diff information");
        
        for (int i = 0; (i + gitDiffOutputFileStartLine) < gitDiffOutputFileContent.size(); i++) {
            assertEquals(gitDiffOutputFileContent.get(gitDiffOutputFileStartLine + i),
                    commitFileContent.get(commitFileStartLine + i),
                    "Git diff output file line does not match commit file line");
        }
    }
    
    /**
     * Returns the index of the first {@link String} in  the given {@link List} of {@link String}s, which starts with
     * the {@link #GIT_DIFF_START_MARKER}.
     * 
     * @param diffLines the {@link List} of {@link String}s in which the {@link String} starting with the
     *        {@link #GIT_DIFF_START_MARKER} should be found
     * @return the index of the first {@link String} starting with the {@link #GIT_DIFF_START_MARKER} or <i>-1</i>, if
     *         no such string is available
     */
    private int getGitDiffStartLine(List<String> diffLines) {
        int gitDiffStartLine = -1;
        int diffLinesCounter = 0;
        while (gitDiffStartLine == -1 && diffLinesCounter < diffLines.size()) {
            if (diffLines.get(diffLinesCounter).startsWith(GIT_DIFF_START_MARKER)) {
                gitDiffStartLine = diffLinesCounter;
            }
            diffLinesCounter++;
        }
        return gitDiffStartLine;
    }
    
    /**
     * Returns the {@link List} of {@link String}s denoting the individual lines of the file in the given directory,
     * which has the {@link #COMMIT_SEQUENCE_FILE_NAME_PREFIX}.
     * 
     * @param commitSequenceDirectory the {@link File} denoting the directory, which contains the commit sequence file
     *        and the corresponding commit files to use in the current test
     * @return the {@link List} of {@link String}s denoting the individual lines of the commit sequence file or
     *         <code>null</code>, if no such file is available
     */
    private static List<String> getCommitSequence(File commitSequenceDirectory) {
        List<String> commitSequence = null;
        File[] commitSequenceDirectoryFiles = commitSequenceDirectory.listFiles(new FilenameFilter() {
            
            @Override
            public boolean accept(File dir, String name) {
                return name.startsWith(COMMIT_SEQUENCE_FILE_NAME_PREFIX);
            }
        });
        if (commitSequenceDirectoryFiles.length == 1) {
            try {
                commitSequence = FileUtilities.getInstance().readFile(commitSequenceDirectoryFiles[0]);
            } catch (FileUtilitiesException e) {
                fail(e);
            }
        }
        return commitSequence;
    }
    
    /**
     * Returns the set of {@link File}s denoting a commit file in the given directory. This method interprets any file
     * as commit file, which does not have the {@link #COMMIT_SEQUENCE_FILE_NAME_PREFIX}.
     * 
     * @param commitSequenceDirectory the {@link File} denoting the directory, which contains the commit sequence file
     *        and the corresponding commit files to use in the current test
     * @return the set of {@link File}s denoting a commit file; may be <i>empty</i>, if no such files exist or returns
     *         <code>null</code>, if an I/O error occurs
     */
    private static File[] getCommitFiles(File commitSequenceDirectory) {
        File[] commitFiles = commitSequenceDirectory.listFiles(new FilenameFilter() {
            
            @Override
            public boolean accept(File dir, String name) {
                return !name.startsWith(COMMIT_SEQUENCE_FILE_NAME_PREFIX);
            }
        }); 
        return commitFiles;
    }
    
}
